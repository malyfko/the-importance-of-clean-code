[Slide 1]
Hi, everyone. My name is Tetiana Platonova, some of you may know me as Tati. I've been in web development
for about 4 years now, and these days I work for blockchain-softwarehouse called "EthWorks" and also I volunteer
at WarsawJS.
But enough about me :) Today I wanna talk to you about why writing a clean code is so important. We're gonna figure out
what is the definition of clean code and what techniques to use in order to make your code clean and DRY.


My talk is inspired by the book "Clean Code" by Robert Martin, known in IT world as "Uncle Bob". I only cover basic
ASPECTS of programming in my talk, but ...

[Slide 2]
The agenda for today's talk looks like this. We gonna go through "why"s and then step-by-step cover all of the rules
you need to follow to make your code "grate again"

[Slide 3]
So what is it - the "Clean Code"? And how to distinguish a good code from the bad code? Basically, even when you write
a good, clean, short code, it still doesn't guarantee that your code will not have bugs or that someone will not find
a better and clearer way to refactor your code. But as you can see here on the slide, the less the person doing review
of you code has to de-code in order to understand it - the better.

And why is it so important - to keep you code clean? There are several reasons:
 - Fist of all, as mentioned before - the code review. Other developers must be able to understand your code without
 having to ask you over and over again for explanations, and without spending a tremendous amount of time figuring out
 what does it do. Same applies for the cooperative development, when two or more programmers are working on the project.

[Slide 4]
Imagine you're buying a house, and it has perfectly working, but ugly door handles. Or that it has windows, that
are letting in the light just fine, but are places so high, that in order to open them to get a fresh air, you first
have to go to the garage (which of course you have to leave house for, cause there is no entrance from inside the
house), and then bring the ladder, climb it and only then open the window. And even if you'd say you're fine with it,
imaging you friends visiting you and having to go through the same steps and having you explaining to them this same
story over and over. Would you even consider buying such a house? Or would you first ask the owner to fix those things?
Or at least dedicate your own time to make it like this?
- Secondly, you yourself as a human tent to forget things. It is physically impossible to remember what you wrote a
half a year, a month, or even a week ago - once you switch your focus to something else, it takes time to recreate
the logical chain.
You might say: "Well, but my code is pretty obvious. Here I declare 'a', 'b'  and 'c' and then I do this and then those
two go there and then they are assigned to the 'd' here" and so on. If you find yourself saying more than one or two
"then" in one sentence - there is a big chance your code is messy and needs refactoring. And the bigger the project
grows - the more refactoring it might need. It's like adding new level to this same house - little by little, it will
be harder to maintain, and one day it'll just all fall apart.

[Slide 5]
But it's not enough to write code well. It has to be kept clean over time. As the time of development passes,
some functions/modules/classes etc might extend. And we must take an active role in preventing degradation. And we must
do it continuously. But how do you do that?
Boy Scouts have a rule: Leave the campground cleaner than you found it. We can apply it here as well. Coming back to
the same metaphor for the house - while adding new level, you occasionally enter other rooms for some tools or
to just relax. And while you're there - spend some time cleaning it! Move some stuff around to clean the mess, maybe,
bring some of them to the garage, so whenever a person from one room wants to use something that used to belong to
somebody from the other room, he/she can just go straight to the garage instead of knocking to that previous owner and
asking for the thing. And that applies to all aspects of your code.

[Slide 6]
Now, moving to more specific steps.
Whether we're writing a function, a class, or even a single variable - the very basic thing we do is naming.
Good naming might save us a lot of time and make our code readable and easy to understand.
First rule we have to follow when naming an entity - it has to be intention-reveling

[Slide 7]
Avoid disinformation. What could "dc" mean in here? "Days counter"? "Data collection"? Or maybe even "document"?

[Slide 8]
Make meaningful distinctions

[Slide 9]
Use pronounceable names

[Slide 10]
Use nouns for class names
Use verbs for methods names
Pick one word per concept (consistency)

[Slide 11]
Use different names for semantically different methods
Let's say, for consistency purpose, you decide to use name "add" in several classes. And it is perfectly fine while
they are semantically equivalent. For example, here we create a new value by adding passed one to the previous.
But then we create a method, that puts received value into a collection. Semantically the action and the returned values
of those methods are different, so it is good to use different name as well. In this case, say, insert.

[Slide 12]
Use solution domain names
Computer science, math, algorithm terms

[Slide 13]
Use problem domain names

[Slide 14]
Stick to English

[Slide 15]
Functions
Be small
Do one thing
    Under 20 lines
    One or two level of indentation

[Slide 16]
Command query separation
This principle states that every method should either be a command that performs an action,
or a query that returns data to the caller, but not both.
In other words, functions should either do something or answer something, not both.

[Slide 17]
Ideally have 0 arguments (Less test cases and mockes)
Avoid flag arguments

[Slide 18]
Prefer exceptions


